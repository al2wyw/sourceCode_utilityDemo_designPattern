表达式求值:
1. 中缀表达式(通常人类识别的表达式，操作符在中间) -> 操作符栈， 结果线性表(复杂不好理解，特别是括号符的处理) / 括号法(玄学) / 中缀表达式构建表达式二叉树(操作符栈, 操作数栈) ->
后缀表达式(计算机可以识别计算) -> 重新扫描后缀表达式，直接运算得到结果
前缀表达式对应于表达式二叉树的前序遍历
中缀表达式对应于表达式二叉树的中序遍历(但是缺失括号，需要按照规则补充括号)
后缀表达式对应于表达式二叉树的后序遍历(一般用来构造表达式二叉树(叶子节点是操作数，其他节点是操作符，没有括号符)，遍历后缀表达式，利用单操作数栈，生成子树，子树作为操作数入栈)
2. 中缀表达式 -> 操作符栈(栈顶和入栈操作符使用优先级表比较优先级,栈顶较高则两个操作数出栈计算后再入操作数栈，操作符入栈，栈顶较低则直接入栈), 操作数栈(好理解) -> 结果
3. 递归实现
总结: 
1. 中缀表达式运算要考虑优先级问题，需要借助操作符栈, 操作数栈，后缀表达式已经涵盖了优先级，无需额外数据结构进行辅助
2. 中缀表达式借助操作符栈, 操作数栈可以获得表达式二叉树

资源调度:


海量数据处理:(hash散列到不同的文件里???)
1.topK:
    1. heap排序
    2. 快速排序的partition实现随机减治(不同于分治)

2.bitset:
缺点:
    1. 现实对象无法很好的转换成数值，或容易出现相同的数值(hash)
    2. 如果数值比较离散不平均(1,2,3,4,9999999)，出现多个位点浪费(hash后取模限定位点大小，但是要解决重复)

3.bloomfilter:
    1. 实体目标数量，误判率 -> hash后需要取多少次值，位点大小
    2. 实体数量一定，hash取值次数越多，误判越低， 位点越多，误判越低
4.tier数(前缀树,字典树)
5.外排
6.mapReduce

排序:
1. 选择，插入，冒泡 -> n2
2. 希尔(插入的优化)，快速(递归+双指针，(随机pivot和尾部元素交换)选尾部元素为pivot，从头开始比较) -> n2 ~ nlogn
3. 堆(父节点比左右子节点都大的完全二叉树，根节点最大为数组的第一个元素，左节点为2i+1，右节点为2i+2)， 归并(n的空间) -> nlogn
4. 计数，桶(计数的优化)，基数(个位，十位，百位...，一轮分配完后按顺序放回数组) 空间都要n -> n+k
稳定性: 相同的数不会交换位置， 希尔，快速，堆 为不稳定
二分查找: mid=(left+right)/2 Q34 Q704 注意while的终止条件

算法思想:
1. 贪心，分冶 -> 分解为子问题，子问题无重叠，解出各个子问题的最优解即得问题的最优解；贪心算法思想: 局部最优+调整=全局最优
2. 动态规划 多阶段决策最优解模型: 即解决问题的过程，需要经历多个决策阶段，每个决策阶段对应一组状态，然后寻找一组决策序列，经过这组决策序列，能产生最终期望求解的最优解
状态转移函数(需要避免重复计算) -> 分解为子问题，互相影响，问题的最优解可分解为子问题的最优解(子问题最优化原理，最优子结构性质)；子问题重叠(出现重复计算的子问题)；无后效性(当前状态的决策不受之前的状态推导路径的影响)

动态规划要点(最优解或者多少解) -> 状态定义； 状态转移； 状态初始化： 定义dp[n]，初始化dp[0]，运算后答案为dp[n-1]； 空间优化

多阶段决策有两种解决思路:
一种是自顶向下的备忘录算法(记忆化搜索)，它采用递归的方式，一步步缩小问题的规模，找到边界(n==0)以后，处理好边界，然后一步步返回，返回更大问题的解，
每获得一个子问题的答案，便保存到备忘录数组p[n][c]，避免下次重复计算，提升了效率。
另一种思路是自底向上的动态规划算法，它从最小的子问题(只包含0号物品)开始处理，然后依次增加可装物品的数量，用数组p[n][c]记录每一个已处理子问题的答案，由于01背包问题具有最优子结构，
每个问题的最优解都是由其子问题的最优解组成，故这样依次递增问题的规模，可以得到最终需要的最优解。
记忆化搜索与动态规划只是一种优化性能的手段(用空间换时间)，一个是自顶向下(从目标状态开始分解成子状态的组合，递归到初始/边界状态)，一个是自底向上(从初始/边界状态开始计算至到目标状态)；
记忆化搜索可能需要一个记录矩阵，但是动态规划有时可以采用滚动数组来减掉一维；动态规划比深度优先记忆化搜索快，但是深度优先使用递归迭代比较好实现(Q1871)

3. 回溯(深度优先 + 剪支), 其实dfs分两种，一种是回溯，需要进行状态回退(不一定有返回值)，一种是递推迭代，需要有返回值
4. 分支限界(广度优先 + 剪支) 上下界(一界合法合理(如贪心求得)，一界不合法不合理(不可达)) + 限界函数(计算当前节点的值，使用上下界剪支)， 搭配队列或者优先队列，在生成子节点时就进行剪枝不将其放入队列
约束条件(去除不合法解)(回溯默认只使用约束函数) + 限界函数(去除非最优解)(回溯也可以使用限界函数来优化剪枝)

算法类别:
动态规划(难度较大) 广度优先 深度优先 双指针 优先队列(堆排序) 字典树 二叉树 链表 数组

算法笔记:
优化思想一般是避免重复计算，避免无用计算，暴力穷举就是一种重复计算的模式 (Q650) 将穷举遍历(时间复杂n)优化为常量遍历(使用set，map)(Q127)，深度优先可以使用记忆化搜索避免重复计算(Q139)
排查问题时for/while循环里面的if和else试一下直接忽略if跑else的逻辑(Q438)
先处理数据再解题，效率更高(Q18) 数组排序，字符串逆序，链表翻转等等
使用long类型来避免int范围不够(Q98)，数学运算导致数据溢出(Q2583) 注意赋值语句两边的操作数都要用高精度(Q18) 注意 1L << 31 和 1 << 31的差异
链表操作全靠快慢双指针(滑动窗口) 检测死循环, (Q142 Q202) 有序数组则靠头尾双指针遍历降低一维循环 (Q15 Q611(巧妙地固定好最长的边)), 使用额外的前缀指针(pre)(Q19)或多条链表(Q86)和指向head的dummy节点可以降低算法难度，while里面套while减少代码复杂度(避免flag Q82)
树的迭代root节点判空代码更优雅，避免子节点判空(Q98)
广度优先可以解决最优(最少步骤)问题(每往下一层就是往前一步)，如果目标明确还可以双向广度优先(节点少的那端可以优先)，节点从队列里取出来时才打上visit标识(Q127) 队列使用的典范(Q662)

记得对比自己的解法和代码实现之间的差异(Q687)
反证法的例子可能是特例，最好多一些例子来反证(Q785 无法推导为有无环问题)
数学公式推导主要是把不定项合并为定项，把k(多)项转化为单项
对复杂问题进行逻辑推导简化成简单问题(Q15)(Q1)
把一个问题分解成多个问题，分别使用动态规划求得其最优解，再逐个比较得到问题的最优解 (Q213)
动态规划 状态转移函数比较难推导(Q300, Q123, Q494, Q718), 有的需要先画图找规律再进行状态转移推导 (Q650)
最短路径可以使用DFS或者BFS，但是Dijkstra(地杰斯特拉)比较快
广度优先 和 动态规划 求解某些问题时可以使用状态压缩(二进制代表状态)来进行状态标识，需要使用位运算

编码:
java中 queue的实现 LinkedList 和 PriorityQueue (add poll peek), stack的实现是 Stack (push pop peek), Queue<Data> queue = new PriorityQueue<>(new Comparator<Data>() {}) -> new PriorityQueue<>((a, b) -> a - b) a - b 升序
char c = s.charAt(int) -> new String(char[]) or StringBuilder.append; 一般对string转为char array后通过start、end下标来"分割"字符串从而避免转成string
len1 = height.length; len2 = height[0].length; int[][] visited = new int[len1][len2];
ascii码128个: +-*/% < 0~9 < A~Z < a~z 可以通过c - 'a'快速转换为数组下标,也可以int i = c - '0'; char c = (char)(i + '0');int char互转
位移运算一定要注意移位符的优先级是最低的，括号不要忘记了，左移一位是乘以2，右移一位是除以2(整数除法) (Q779) 任何数减1再异或可以求1的个数，任何数异或0xffffff或0b111111可以取反
一维数组无法使用Arrays.sort的comparator接口进行降序排序，二维可以(Q1696)


数论算法
字符串匹配(kmp匹配，前缀树(字典树，注意字符结尾辨识，根节点为一个Node而不是Node数组 Q2707))
图论(无向图: 最小生成树(无环图，n个顶点，n-1条边)，最短路径; 有向无环图(工程依赖相关)：拓扑排序AOV值在顶点(一般排序不唯一)，关键路径AOE值在边(最长路径))
Prime和Dijkstra类似(贪心算法)需要记录访问过的顶点和更新访问过的顶点到其他顶点的最小距离
拓扑排序使用队列，每次将入度(入向边的个数)为0的顶点入列，出列时把出列顶点指向的顶点的入度减1，如果队列为空时还有顶点没有访问到，则有环
需要数学公式推导的太难(最后的代码实现与问题相去甚远)，放弃(Q96,Q365)
TSP旅行家问题(np完全问题)(多项式求解问题) 从某个节点出发经过所有节点的最短路径 ???

树形DP -> 父子节点冲突(Q337)
状压DP -> 玉米田的种法数量 F[i][j] = ∑ F[i-1][k] (j, k是二进制代表的状态，F[i][j]代表第i行状态为j的种法数量, 是i-1行各种合法状态k对应的种法的和)


完全背包(每种石头无限个) -> 根据背包装载空间 -> 多重背包(每种石头有限个) -> 每种石头平铺开 -> 01背包(每种石头一个)
01背包:
/**
 * 状态 F(i,j): 前 i个物品放入大小为 j的背包中所获得的最大价值
 * 递推关系:	当前背包放不下新增物品时 W(i-1) < j:  F(i,j) = F(i-1,j)
 *     		放得下时: F(i,j) = max{ (F(i-1, j), F(i-1, j - W(i-1)) + V(i - 1)}
 * W(i-1):  新增物品的大小
 * V(i-1):  新增物品的价格
 * F(i-1,j): 表示不把第i个物品放入背包中， 所以它的价值就是前i-1个物品放入大小为j的背包的最大价值
 * F(i-1, j - W[i]) + V[i]：表示把第i个物品放入背包中，价值增加V[i], 但是需要腾出j - W[i]的大小放第i个商品
 * 初始状态：F(i,0) = F(0,j) = 0  第0行和第0列都为0，表示没有装物品时的价值都为0
 * 返回值：F(i,j)
 */
int v[n],w[n];
int f[n+1][m+1]; +1!!! 这个由递推公式的定义来决定，Q45不需要+1
for(int i  = 1; i <= n ; i++)
    for(int j = 1; j <= m ;j++)
    {
        if(j >= w[i-1])
        f[i][j] = max(f[i-1][j], f[i -1][j - w[i-1]] + v[i-1]); 数据表格(i，j)项只跟正下方左边和正下方的数据有关!!!
        else
        f[i][j] = f[i - 1][j];
    }
return f[n][m];
以下减少一维的公式由以上的二维公式推导得到:
int v[n],w[n],f[m+1];
for(int i  = 1; i <= n ; i++)
    for(int j = m; j >=w[i-1] ;j--) 逆序!!! 自己画表格理解
        f[j] = max(f[j], f[j - w[i-1]] + v[i-1]);
return f[m];
01背包的变形: 三维(可优化成二维)(Q474) 一维(不是优化空间)(Q198) 二维(数学推导再优化成一维)(Q494)

完全背包:
int v[N],w[N];
int f[N+1][M+1];
for(int i  = 1; i <= n ; i++)
    for(int j = 1; j <= m ;j++)
          for(int k = 0; k*w[i-1] <= j;k++) //k从0开始，f[i][j]初始为极小值
                f[i][j] = max(f[i][j],f[i - 1][j - k*w[i-1]] + k*v[i-1]);
把与k相关的多项式移除(f[i][j-w[i-1]]正好可以替代):
int v[N],w[N];
int f[N+1][M+1];
for(int i  = 1; i <= n ; i++)
    for(int j = 1; j <= m ;j++)
        if(j >=w[i-1])
            f[i][j] = max(f[i-1][j],f[i][j - w[i-1]] + v[i-1]); 数据表格(i，j)项只跟本行左边和正下方的数据有关!!!
        else
            f[i][j] = f[i-1][j];
以下减少一维的公式由以上的二维公式推导得到:
int v[N],w[N],f[M+1];
for(int i  = 1; i <= n ; i++)
    for(int j = w[i-1]; j <= m ;j++)
        f[j] = max(f[j],f[j - w[i-1]] + v[i-1]);

完全背包的一种简单理解方式: F(j)=max{F(j−w[i])+v[i]} i=0…n−1 -> F(j) 为j状态下的最优解，即为F(j-w[i])的最优解 + v[i]的最优解，
这里需要枚举所有的v，因为最终的解即为上一个状态的最优解+最后一个决策(v任意选一，不可弃选) (Q322 Q279)
注意dp和dp[0]的初始化，避免max+1太大越界(Q322)，以下是(仅供)参考示例:
int[] dp = new int[amount + 1]; Arrays.fill(dp, max); dp[0] = 0;
for (int j = 1; j <= amount; j++) {
    for (int i = 0; i < coins.length; i++) {
        if (coins[i] <= j) {
            dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1); //dp[j]初始为极大值
        }
    }
}
return dp[amount];
求极值问题两种方式都可以得到解，求总数问题也可以 (Q377 Q518(要解决重复问题，反而使用第一种方式比较合适))

总结:
01背包是当前待选物选or不选的问题，完全背包是当前待选物选哪个的问题(必选其一不可弃选)

记忆化搜索:
完全背包可以使用一维数据dp[w]，因为每次决策只是重量不同，可选择的对象是相同的； 01背包只能使用map，因为每次决策重量不同，可选对象也不同(范围在缩小)
