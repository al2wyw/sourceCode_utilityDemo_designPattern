唯一key生成
数值型
-- 依靠时间
    snowflake雪花算法64位的数字(时间戳（毫秒级）+ 集群ID+机器ID + 序列号(当前时间戳对应的自增序列))(时间回拨问题，使用上一次生成的id顺推下去)
    UidGenerator64位的数字(时间戳（秒级）+机器ID+ 序列号(当前时间戳对应的自增序列))，cache模式预先分配id，时间戳为逻辑自增序列，不会回退，弱依赖系统时间
    同一个时间戳内是乱序的，趋势有序不是绝对有序
-- 依靠数据库，数据库表sequence生成(无时间顺序)
字符型
-- UUID

幂等
-- 超时重试
-- 并发调用
方案:
1. MVCC(或唯一索引) 防止并发更新
2. 有限状态机 防止相同状态重复更新
3. 服务器端token申请，再用token来访问，支付领域常用
4. 请求带唯一的request id，request id落库判重， 如果新启一张表存在事务问题

逆向
-- 事务回滚

数据一致性
一致性模型: 强一致性，线性一致性，顺序一致性，因果一致性，读写一致性(读已写)，单调一致性(单调读)，会话一致性，最终一致性，弱一致性
线性一致性: 系统提供只有一个副本的假象
顺序一致性: 系统要求所有进程感知到相同的写操作顺序，读操作是乱序的
因果一致性: 系统服从因果关系所规定的操作顺序，包含了读写一致性
读写一致性(读已写): 系统提供操作人读到自己最新的写操作
单调一致性(单调读): 系统提供读取到他人最新的操作后不回退
会话一致性：一个会话内保证单调读，单调写，和读已写
-- 一阶段提交(Best Efforts 1PC,就是无协调者的普通事务)
刚性事务 ACID:
-- XA分布式事务 二阶段提交(协调者和参与者发生两次完整的req-res交互)
    prepare -> submit
    缺点: 1. 协调者单点故障 2. 第二阶段某个参与者宕机不一致 3. 参与者超时阻塞，资源长期hold住
-- XA分布式事务 三阶段提交(主要解决协调者单点和参与者超时阻塞的问题，增加超时控制和三个阶段交互)
    canCommit(询问是否可以执行，提前发现问题，超时导致失败) -> preCommit(二阶段的prepare，超时导致成功) -> doCommit(二阶段的submit)
    缺点: 1. 第三阶段某个参与者超时自动commit，实际上协调者发送了cancel(网络故障不可达, 脑裂)
-- Paxos协议
-- ZooKeeper ZAB协议(Paxos协议的改进)
-- Etcd Raft协议(Paxos协议的改进)
   1. start -> Follower -> Candidate -> Leader
   2. election term(election epoch), commitIndex(zxid)
   3. 选举结束后没有同步上一轮遗留的日志数据
   总结: ZAB和Raft本质上是一样的，实现细节不同
柔性事务 BASE:
-- TCC:(不阻塞资源，需要把接口一拆为三)
    try(锁定资源) -> confirm(更新资源) -> cancel(取消锁定资源)
-- Sagas异步消息协作:
    create(生成pending状态操作记录) -> confirm(提交操作状态更新) -> cancel(逆向操作)
-- 本地消息表 + 状态流转:
    1. 把事件和对应的操作使用本地事务一起记录到本地库(其中事件写入消息表, 可以轮询保证消息发送成功)
    2. 消息状态记录表发送者和接收者都对其进行更新,保证消费端一致
-- 本地重试 + 状态流转 -> writeAheadLog + DB记录任务状态
-- 可靠消息(事务型消息): 中间件使用half(2PC)消息(half消息事务包裹本地事务)，保证发送端一致(发送端提供查询接口查询本地事务状态)
-- 可靠消息(非事务型消息): 本地事务包裹消息发送，消息发送失败即回滚本地事务
-- 事务补偿: 逆向接口, 线下日志补偿，线下消息补偿
特别说明:
-- 状态流转: 每个操作都有一个对应的记录，维护记录的初始，已完成，已撤销等状态
-- 后置提交(大大减小不一致的几率，但是要加长hold住链接的时间)

解决分布式事务的最好办法就是不考虑分布式事务: 把分布式的事务过程拆解成多个中间状态，中间状态的东西不允许用户直接操作，
等状态都一致成功，或者检测到不一致的时候全部失败掉, 就解耦了这个强一致性的过程

系统稳定性
-- 降级
-- 超时熔断
-- 流量控制 (避免卡时间点重置整个计数)
    1. 令牌桶 匀速生成令牌放入桶中，超过桶容量后丢弃令牌，请求时从桶中消耗令牌(guava RateLimiter)； 支持突发流量
    2. 漏桶 水桶从底部以恒定速率漏水，漏多少水则处理多少请求(处理不来的请求会缓存起来)；恒定流量
    3. 滑动窗口 把时间划分为细小的时间窗口，每个窗口有计数器，可以放通的流量总数为滑动窗口横跨的几个窗口的计数器总和，当滑动窗口的个数为1时即为普通计数器限流； 支持突发流量
-- 异常重试
    1. 异常识别
    2. 稳定性
-- 隔离

MPP vs NUMA vs SMP:
MPP 由shared nothing的多个SMP组成
MapReduce 也是并行架构，跟MPP相类似