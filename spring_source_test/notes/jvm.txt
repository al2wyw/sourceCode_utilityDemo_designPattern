内存分布
公共区域: 堆 方法区(含运行期常量池)
线程独享: 虚拟机栈 本地方法栈 函数计数器
栈帧: 包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息，局部变量主要是存放方法参数以及方法内部定义的局部变量
metaspace和perm的区别:
metaspace是不连续的直接内存
类都挂载在类加载器名下，会随着类加载器一起被回收
每个类加载器有单独的存储空间
常量池:
运行期常量池:
由类文件的常量池表的内容加载到内存，由符号引用生成对应的直接引用以及静态常量字段，属于方法区的一部分
字符串常量池:
为什么字符串常量池从永久代移动到堆区: 因为永久代垃圾回收频率低，而字符串使用频率比较高，不能及时回收字符串，会导致导致永久代内存不足，就被移动到了堆内存中

对象的创建:
分配内存的两种方法:
空闲列表(内存不规整，记录空闲的内存块)
指针碰撞(内存规整，指针指向空闲部分的开始地址)
栈上分配 -> TLAB(避免并发CAS分配内存) -> 堆

垃圾回收
引用计数，可达性分析
标记复制 标记清除 标记整理
oopMap: 加速gc root的遍历, gc root实例的字典集合
安全点: 线程主动轮询安全点，线程达到安全点则停止，gc线程需要等待运行中的线程达到安全点
安全区域: 某个代码区域内引用关系不变则可作为安全区域，运行中的线程进入安全区域后gc线程无需等待即可发起gc收集，如果gc收集未完成，运行中的线程必须等待gc完成后才可离开安全区域

CMS:
初始标记(stw): 只遍历gc root，速度快
并发标记(含预清理): 从每个gc root出发标记各个存活对象(业务线程也在同时运行)
重新标记(stw): 修正并发标记期间因业务线程而变动的那一部分对象
并发清除: 将那些未被标记为存活的对象标记为不可达(业务线程也在同时运行)
promotion failed是指担保机制确定老年代是否有足够的空间容纳新来的对象，如果担保机制说有，但是真正分配的时候发现由于碎片导致找不到连续的空间而失败
concurrent mode failure是指并发周期还没执行完，用户线程就来请求比预留空间更大的空间了，即后台线程的收集没有赶上应用线程的分配速度
优点: 并发收集、低延迟停顿时间短
缺点: 内存碎片、停顿不可预测

G1
过程和cms相似(并发清除变成复制清除(stw))，并发使用多个cpu来缩短复制清除stw时间
分代收集，g1负责内存全区的gc
内存划分: eden, survivor, old, Humongous(大对象区)，每个分区的内存被划分为多个相等的独立区域region
空间整合，从整体看是标记-整理算法，从局部看是两个region之间的复制，保证没有内存碎片
可预测停顿时间(单位时间内的停顿时间可预设): 通过跟踪region的垃圾回收价值，在有限的停顿时间内优先回收价值高的region，避免全区域的垃圾回收(每次增量回收)
gc模式: young gc, mixed gc(cms垃圾回收一样), full gc(降级为简单的全局垃圾回收serial old)
在小内存应用上 CMS 的表现大概率会优于G1，而 G1 在大内存应用上则发挥其优势
优点: 停顿可预测、充分利用多核处理器停顿时间短、适合大内存
缺点: 复制整合有额外成本

ZGC jdk11开始，支持TB级别内存，太复杂暂时放弃


分配和回收策略
对象优先在Eden分配
达到一定年限的对象晋升到老年代
大对象直接分配在老年代
动态年限(相同年龄的对象大小总和大于survivor的一半，则大于改年龄的可以直接进入老年代)
空间分配担保(只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC)

类加载
加载，生成class对象作为入口
连接:
校验，准备(分配空间置为0)，解析(符号引用转直接引用)
初始化，调用clinit
类加载的触发时机:
遇到new、getstatic、putstatic或invokestatic这四条字节码指令时: new, 读取或设置静态字段，调用静态方法
反射调用对应的类
动态语言使用REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄
拥有default方法的接口的default方法被调用
以下不会引起类初始化:
通过类引用其常量字段(常量的值一定要编译期间可以确定的，public static final Integer I = 1;会引起初始化)
通过类数组定义来引用类 (Person[] array = new Person[3]; 不会初始化 Person)
通过类引用其父类的静态字段(坑)

对象初始化顺序: (代码块、成员变量按出现的先后顺序)
父类静态区（代码块、成员变量）
子类静态区（代码块、成员变量）
父类普通代码块、成员变量
父类构造方法
子类普通代码块、成员变量
子类构造方法

字节码执行引擎
解析调用(invokestatic 和 invokespecial, 在编译期就确定了调用对象)
静态分派调用(重载)
动态分派调用(重写，动态解析把符号引用转直接引用)

编译优化
编译期优化
泛型擦除
自动拆装箱
遍历循环

运行期优化
解释执行 与 编译执行 相互进行：解释执行由于触发热点进行运行期编译转化为编译执行；deoptimization 激进优化代码回退到前一级的优化代码甚至回退到解释执行
分层编译 1(client 稳健优化，不profile) 2(client 进行部分profile) 3(client 进行完全profile) 4(server 激进优化)
热点代码探测: 函数计数器，回边计数器(循环体，栈上替换-代码地址替换)
client编译器架构：
前端 -- 字节码 -》内联，常量传播等 -》HIR(高级中间码) -》空值检查消除，范围检查消除 -》优化后的HIR
后端 -- HIR -》转化 -》LIR(低级中间码) -》寄存器分配等 -》机器代码
提前编译 对比 运行时编译： 各有优缺点
方法内联: 避免方法调用的成本，是所有优化的基石
逃逸分析: 栈上分配, 标量替换(标量是不可拆分的基础类型，不在堆上生成对象，而是直接把对象的字段变成局部变量分配在栈上), 同步锁消除(去除同步锁synchronized)
公共子表达式消除: 如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为公共子表达式
数组边界检查消除: 编译器只要通过数据流分析就可以判定取值范围永远在区间之内，那么就可以把数组的上下界检查消除掉

内存模型
原子性
可见性

锁优化
自旋锁
JIT编译优化: 锁粗化 锁移除
synchronized 锁膨胀的过程: 偏向锁（进入偏向后不做任何操作） -> 轻量级锁（通过cas把mark word拷贝到线程栈上的lock record，不做其他操作） -> 重量级锁（互斥量）
