内存分布
公共区域: 堆 方法区(含运行期常量池)
线程独享: 虚拟机栈 本地方法栈 函数计数器
metaspace和perm的区别:
metaspace是不连续的直接内存
类都挂载在类加载器名下，会随着类加载器一起被回收
每个类加载器有单独的存储空间
常量池:
运行期常量池:
由类文件的常量池表的内容加载到内存，由符号引用生成对应的直接引用以及静态常量字段，属于方法区的一部分
字符串常量池:
为什么字符串常量池从永久代移动到堆区: 因为永久代垃圾回收频率低，而字符串使用频率比较高，不能及时回收字符串，会导致导致永久代内存不足，就被移动到了堆内存中

对象的创建:
分配内存的两种方法:
空闲列表(内存不规整，记录空闲的内存块)
指针碰撞(内存规整，指针指向空闲部分的开始地址)
栈上分配 -> TLAB(避免并发CAS分配内存) -> 堆

垃圾回收
引用计数，可达性分析
标记复制 标记清除 标记整理
安全点/安全区域

CMS:
初始标记(stw): 只遍历gc root，速度快
并发标记(含预清理): 从每个gc root出发标记各个存活对象(业务线程也在同时运行)
重新标记(stw): 修正并发标记期间因业务线程而变动的那一部分对象
并发清除: 将那些未被标记为存活的对象标记为不可达(业务线程也在同时运行)
promotion failed是指担保机制确定老年代是否有足够的空间容纳新来的对象，如果担保机制说有，但是真正分配的时候发现由于碎片导致找不到连续的空间而失败
concurrent mode failure是指并发周期还没执行完，用户线程就来请求比预留空间更大的空间了，即后台线程的收集没有赶上应用线程的分配速度

G1
并发标记，并发使用多个cpu来缩短stw时间
分代收集
空间整合，从整体看是标记-整理算法，从局部看是两个region之间的复制，保证没有内存碎片
可预测停顿时间(单位时间内的停顿时间可预设): 通过跟踪region的垃圾回收价值，在有限的停顿时间内优先回收价值高的region，避免全区域的垃圾回收
内存划分: eden, survivor, old, Humongous(大对象区)
gc模式: young gc, mixed gc(cms垃圾回收一样), full gc(降级为简单的全局垃圾回收serial old)
在小内存应用上 CMS 的表现大概率会优于G1，而 G1 在大内存应用上则发挥其优势

分配和回收策略
对象优先在Eden分配
达到一定年限的对象晋升到老年代
大对象直接分配在老年代
动态年限(相同年龄的对象大小总和大于survivor的一半，则大于改年龄的可以直接进入老年代)
空间分配担保

类加载
加载，生成class对象作为入口
连接:
校验，准备(分配空间置为0)，解析(符号引用转直接引用)
初始化，调用clinit
类加载的触发时机:
遇到new、getstatic、putstatic或invokestatic这四条字节码指令时: new, 读取或设置静态字段，调用静态方法
反射调用对应的类
动态语言使用REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄
拥有default方法的接口的default方法被调用
以下不会引起类初始化:
通过类引用其常量字段(常量的值一定要编译期间可以确定的，public static final Integer I = 1;会引起初始化)
通过类数组定义来引用类 (Person[] array = new Person[3]; 不会初始化 Person)
通过类引用其父类的静态字段(坑)

对象初始化顺序: (代码块、成员变量按出现的先后顺序)
父类静态区（代码块、成员变量）
子类静态区（代码块、成员变量）
父类普通代码块、成员变量
父类构造方法
子类普通代码块、成员变量
子类构造方法

字节码执行引擎
解析调用(invokestatic 和 invokespecial, 在编译期就确定了调用对象)
静态分派调用(重载)
动态分派调用(重写，动态解析把符号引用转直接引用)

编译优化
编译期优化
泛型擦除
自动拆装箱
遍历循环

运行期优化
方法内联: 避免方法调用的成本
逃逸分析: 栈上分配, 标量替换(标量是不可拆分的基础类型，不生成可逃逸的对象，而是直接把对象字段变成局部变量), 同步锁消除(去除同步锁synchronized)
公共子表达式消除: 如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为公共子表达式
数组边界检查消除: 编译器只要通过数据流分析就可以判定取值范围永远在区间之内，那么就可以把数组的上下界检查消除掉

内存模型
原子性
可见性

锁优化
synchronized 锁膨胀的过程
